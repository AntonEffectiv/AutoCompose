{"version":3,"file":"AutoCompose.js","sources":["../src/constants.js","../src/utils.js","../src/node-utils.js","../src/AutoCompose.js"],"sourcesContent":["// Invisible character\nexport const POSITIONER_CHARACTER = \"\\ufeff\";\n\nexport const FONT_PROPERTIES = [\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n    'fontStyle',\n    'fontVariant',\n    'fontWeight',\n    'fontStretch',\n    'fontSize',\n    'fontSizeAdjust',\n    'fontFamily',\n\n    'textAlign',\n    'textTransform',\n    'textIndent',\n    'textDecoration',  // might not make a difference, but better be safe\n\n    'letterSpacing',\n    'wordSpacing',\n\n    'tabSize',\n    'MozTabSize'\n];\n\nexport const HOST_PROPERTIES = [\n    ...FONT_PROPERTIES,\n    'direction',  // RTL support\n    'boxSizing',\n    'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n\n    'borderRightWidth',\n    'borderLeftWidth',\n\n    'paddingRight',\n    'paddingLeft',\n];\n\nexport const CLONE_PROPERTIES = [\n    ...HOST_PROPERTIES,\n    'overflowX',\n    'overflowY',  // copy the scrollbar for IE\n\n    'borderTopWidth',\n    'borderBottomWidth',\n    'borderStyle',\n\n    'paddingTop',\n    'paddingBottom',\n\n    'lineHeight',\n];\n\nexport const FILLER = ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;';\n\nexport const INLINE_SUGGESTION_ID = '___autocompose_inline_suggestion___';\n","export const ensure = (context, object, keys) => {\n    [].concat(keys).forEach(key => {\n        if (typeof object[key] === 'undefined') {\n            throw new Error(`AutoCompose: Missing required parameter, ${context}.${key}`);\n        }\n    });\n};\n\nexport const ensureAnyOf = (context, object, keys) => {\n    let currentKey;\n    if (!keys.some(key => (\n        typeof object[currentKey = key] !== 'undefined'\n    ))) throw new Error(`AutoCompose: Missing required parameter, ${context}.${currentKey}`);\n};\n\nexport const ensureType = (context, object, key, type) => {\n    [].concat(object[key]).forEach(value => {\n        const valueType = typeof value;\n        if (valueType !== type && valueType !== 'undefined') {\n            throw new TypeError(`AutoCompose: Invalid Type for ${context}.${key}, expected ${type}`);\n        }\n    });\n};\n\nexport const getCursorPosition = input => {\n    return [input.selectionStart, input.selectionEnd].sort((a, b) => a - b);\n};\n\nexport const makeAsyncQueueRunner = () => {\n    let i = 0;\n    let queue = [];\n\n    return (f, j) => {\n        queue[j - i] = f;\n        while (queue[0]) ++i, queue.shift()();\n    };\n};\n\nexport const data = (element, key, value) => {\n    key = 'autosuggest_' + key;\n    if (typeof value !== 'undefined') {\n        element.dataset[key] = JSON.stringify(value);\n    } else {\n        value = element.dataset[key];\n        return typeof value !== 'undefined' ? JSON.parse(element.dataset[key]) : value;\n    }\n};\n","export const getGlobalOffset = $0 => {\r\n    let node = $0, top = 0, left = 0;\r\n\r\n    do {\r\n        left += node.offsetLeft;\r\n        top += node.offsetTop;\r\n    } while (node = node.offsetParent);\r\n\r\n    return { left, top };\r\n};\r\n\r\nexport const getSelectedTextNodes = () => {\r\n    const selection = window.getSelection();\r\n    if (!selection.isCollapsed) return {};\r\n\r\n    let { startContainer: node, startOffset: offset } = selection.getRangeAt(0);\r\n    if (node.nodeType !== node.TEXT_NODE) {\r\n        try {\r\n            node = getFirstChildNode(node.childNodes[offset]);\r\n            offset = 0;\r\n        } catch (e) {\r\n            try {\r\n                node = getLastChildNode(node.childNodes[offset - 1]);\r\n                offset = node.nodeValue ? node.nodeValue.length : null;\r\n            } catch(e) {}\r\n        }\r\n    }\r\n\r\n    return { node, offset };\r\n};\r\n\r\nexport const createNode = html => {\r\n    var div = document.createElement('div');\r\n    div.innerHTML = html.trim();\r\n    return div.firstChild;\r\n};\r\n\r\nexport const getFirstChildNode = node => {\r\n    let nextNode = node;\r\n    while (nextNode.firstChild) nextNode = nextNode.firstChild;\r\n    return nextNode;\r\n};\r\n\r\nexport const getLastChildNode = node => {\r\n    let nextNode = node;\r\n    while (nextNode.lastChild) nextNode = nextNode.lastChild;\r\n    return nextNode;\r\n};\r\n\r\nexport const getNextNode = (node, root) => {\r\n    let nextNode;\r\n    if (node.nextSibling)\r\n        nextNode = node.nextSibling;\r\n    else {\r\n        nextNode = node.parentNode;\r\n        while (nextNode !== root && !nextNode.nextSibling)\r\n            nextNode = nextNode.parentNode;\r\n        if (nextNode && nextNode !== root)\r\n            nextNode = nextNode.nextSibling\r\n        else return;\r\n    }\r\n\r\n    return getFirstChildNode(nextNode);\r\n};\r\n\r\nexport const getPrevNode = (node, root) => {\r\n    let prevNode;\r\n    if (node.previousSibling)\r\n        prevNode = node.previousSibling;\r\n    else {\r\n        prevNode = node.parentNode;\r\n        while (prevNode !== root && !prevNode.previousSibling)\r\n            prevNode = prevNode.parentNode;\r\n        if (prevNode && prevNode !== root)\r\n            prevNode = prevNode.previousSibling\r\n        else return;\r\n    }\r\n\r\n    return getLastChildNode(prevNode);\r\n};\r\n\r\nexport const removeNodesBetween = (startContainer, endContainer) => {\r\n    if (startContainer === endContainer) return;\r\n    let node = getNextNode(startContainer);\r\n    while (node !== endContainer) {\r\n        node.parentNode.removeChild(node);\r\n        node = getNextNode(startContainer);\r\n    }\r\n};\r\n\r\nexport const getNodeValue = node => {\r\n    if (node.tagName && node.tagName === 'BR')\r\n        return '\\n';\r\n    return node.nodeValue || '';\r\n};\r\n\r\nexport const setSelection = callback => {\r\n    const selection = window.getSelection();\r\n    const range = document.createRange();\r\n    callback(range);\r\n    selection.removeAllRanges();\r\n    selection.addRange(range);\r\n};","import { INLINE_SUGGESTION_ID } from './constants';\nimport { data, ensure, ensureType } from './utils';\nimport {\n    getSelectedTextNodes,\n    getNodeValue,\n    setSelection,\n    getPrevNode,\n    getNextNode,\n    createNode,\n} from './node-utils';\n\nclass AutoCompose {\n    constructor(options, ...inputs) {\n        if (!options)\n            throw new Error(`AutoCompose: Missing required parameter, options`);\n\n        if (typeof options === 'function')\n            options = { composer: options };\n\n        this.inputs = [];\n        this.onChange = options.onChange || Function.prototype;\n        this.onReject = options.onReject || Function.prototype;\n\n        ensure('AutoCompose', options, 'composer');\n        ensureType('AutoCompose', options, 'composer', 'function');\n        this.composer = options.composer;\n\n        events: {\n            const self = this;\n            let handledInKeyDown = false, suggestionNode = null, activeSuggestion = null;\n\n            const clearSuggestion = normalize => {\n                const parentNode = suggestionNode.parentNode;\n                parentNode.removeChild(suggestionNode);\n                normalize && parentNode.normalize();\n                suggestionNode = activeSuggestion = null;\n            };\n\n            const acceptSuggestion = ignoreCursor => {\n                const suggestion = suggestionNode.firstChild.nodeValue;\n                suggestionNode.parentNode.insertBefore(suggestionNode.firstChild, suggestionNode);\n                const insertedNode = suggestionNode.previousSibling;\n\n                clearSuggestion();\n                !ignoreCursor && setSelection(range => {\n                    range.setStartAfter(insertedNode);\n                    range.setEndAfter(insertedNode);\n                });\n\n                this.onChange({\n                    suggestion: activeSuggestion,\n                    acceptedSuggestion: suggestion\n                });\n            };\n\n            const rejectSuggestion = () => {\n                clearSuggestion();\n                this.onReject({ suggestion: activeSuggestion });\n            };\n\n            const isSuggestionTextNode = node => node.parentNode === suggestionNode;\n            const isAfterSuggestionNode = node => {\n                while ((node = getPrevNode(node)) && isSuggestionTextNode(node));\n                return Boolean(node);\n            };\n\n            this.onBlurHandler = () => suggestionNode && clearSuggestion(true);\n            this.onKeyDownHandler = function (e) {\n                if (suggestionNode) {\n                    if (e.keyCode === 9 || e.keyCode === 39 || e.keyCode === 40) {\n                        acceptSuggestion();\n                        handledInKeyDown = true;\n                        e.preventDefault();\n                    } else {\n                        rejectSuggestion();\n                    }\n                }\n            };\n\n            let keyUpIndex = 0;\n            this.onKeyUpHandler = function (e) {\n                if (e.type === 'keyup' && handledInKeyDown) {\n                    handledInKeyDown = false;\n                    return;\n                }\n\n                let { node: textNode, offset } = getSelectedTextNodes();\n                if (!textNode) return;\n\n                const isSuggestionNode = isSuggestionTextNode(textNode);\n                if (e.type === 'mouseup' && suggestionNode) {\n                    if (isSuggestionNode && offset) {\n                        textNode.nodeValue = textNode.nodeValue.slice(0, offset);\n                        return acceptSuggestion();\n                    } else if (isAfterSuggestionNode(textNode)) {\n                        return acceptSuggestion(true);\n                    }\n                }\n\n                if (isSuggestionNode) {\n                    try {\n                        textNode = getPrevNode(suggestionNode);\n                        offset = textNode.nodeValue.length;\n                    } catch(e) {\n                        textNode = getNextNode(suggestionNode);\n                        offset = 0;\n                    }\n                }\n                if (textNode.nodeType !== textNode.TEXT_NODE) return;\n\n                suggestionNode && rejectSuggestion();\n                postValue: {\n                    let postValue = textNode.nodeValue.slice(offset);\n                    if (postValue.trim()) return;\n\n                    let node = textNode;\n                    while (node = getNextNode(node, this)) {\n                        postValue += getNodeValue(node);\n                        if (postValue.trim()) return;\n                    }\n                }\n\n                let preValue = '';\n                preValue: {\n                    preValue = textNode.nodeValue.slice(0, offset);\n\n                    let node = textNode;\n                    while (node = getPrevNode(node, this)) {\n                        preValue = getNodeValue(node) + preValue;\n                    }\n                }\n\n                handlesuggestion: {\n                    keyUpIndex++;\n                    (asyncReference => {\n                        self.composer.call(this, preValue, result => {\n                            if (!result || asyncReference !== keyUpIndex) return;\n                            const textAfterCursor = textNode.nodeValue.slice(offset);\n                            const parentNode = textNode.parentNode;\n                            const referenceNode = textNode.nextSibling;\n\n                            textNode.nodeValue = textNode.nodeValue.slice(0, offset);\n                            parentNode.insertBefore(document.createTextNode(textAfterCursor), referenceNode);\n\n                            activeSuggestion = result;\n                            suggestionNode = createNode(`<span>${result}</span>`);\n                            suggestionNode.style.opacity = 0.7;\n                            suggestionNode.id = INLINE_SUGGESTION_ID;\n                            parentNode.insertBefore(suggestionNode, referenceNode);\n\n                            setSelection(range => {\n                                range.setStartBefore(suggestionNode);\n                                range.setEndBefore(suggestionNode);\n                            });\n                        });\n                    })(keyUpIndex);\n                }\n            };\n        }\n\n        // initialize events on inputs\n        this.addInputs(...inputs);\n    }\n\n    addInputs(...args) {\n        const inputs = Array.prototype.concat.apply([], args.map(d => d[0] ? Array.prototype.slice.call(d, 0) : d));\n\n        inputs.forEach(input => {\n            // validate element\n           if (!input.isContentEditable) {\n                throw new Error('AutoCompose: Invalid input: only contenteditable elements are supported');\n            }\n\n            // init events\n            input.addEventListener('blur', this.onBlurHandler);\n            input.addEventListener('keyup', this.onKeyUpHandler);\n            input.addEventListener('mouseup', this.onKeyUpHandler);\n            input.addEventListener('keydown', this.onKeyDownHandler, true);\n\n            data(input, 'index', this.inputs.push(input) - 1);\n        });\n    }\n\n    removeInputs(...args) {\n        const inputs = Array.prototype.concat.apply([], args.map(d => d[0] ? Array.prototype.slice.call(d, 0) : d));\n\n        inputs.forEach(input => {\n            const index = data(input, 'index');\n            if (!isNaN(index)) {\n                this.inputs.splice(index, 1);\n\n                // destroy events\n                input.removeEventListener('blur', this.onBlurHandler);\n                input.removeEventListener('keyup', this.onKeyUpHandler);\n                input.removeEventListener('mouseup', this.onKeyUpHandler);\n                input.removeEventListener('keydown', this.onKeyDownHandler, true);\n            }\n        });\n    }\n\n    destroy() {\n        this.removeInputs(this.inputs);\n    }\n}\n\nexport default AutoCompose;\n"],"names":["FONT_PROPERTIES","HOST_PROPERTIES","CLONE_PROPERTIES","INLINE_SUGGESTION_ID","ensure","context","object","keys","concat","forEach","key","Error","ensureType","type","valueType","value","TypeError","data","element","dataset","JSON","stringify","parse","getSelectedTextNodes","selection","window","getSelection","isCollapsed","getRangeAt","node","startContainer","offset","startOffset","nodeType","TEXT_NODE","getFirstChildNode","childNodes","e","getLastChildNode","nodeValue","length","createNode","div","document","createElement","innerHTML","html","trim","firstChild","nextNode","lastChild","getNextNode","root","nextSibling","parentNode","getPrevNode","prevNode","previousSibling","getNodeValue","tagName","setSelection","range","createRange","removeAllRanges","addRange","AutoCompose","options","composer","inputs","onChange","Function","prototype","onReject","self","handledInKeyDown","suggestionNode","activeSuggestion","clearSuggestion","removeChild","normalize","acceptSuggestion","suggestion","insertBefore","insertedNode","ignoreCursor","setStartAfter","setEndAfter","rejectSuggestion","isSuggestionTextNode","isAfterSuggestionNode","Boolean","onBlurHandler","onKeyDownHandler","keyCode","preventDefault","keyUpIndex","onKeyUpHandler","textNode","isSuggestionNode","slice","postValue","preValue","call","result","asyncReference","textAfterCursor","referenceNode","createTextNode","style","opacity","id","setStartBefore","setEndBefore","addInputs","args","Array","apply","map","d","input","isContentEditable","addEventListener","push","index","isNaN","splice","removeEventListener","removeInputs"],"mappings":"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"}